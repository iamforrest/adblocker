{"version":3,"file":"adblocker.umd.min.js","sources":["esm/index.js"],"sourcesContent":["/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { parse } from 'tldts-experimental';\nimport { FiltersEngine, isUTF8, Request, StreamingHtmlFilter, } from '@cliqz/adblocker';\nfunction isFirefox() {\n    try {\n        return navigator.userAgent.indexOf('Firefox') !== -1;\n    }\n    catch (e) {\n        return false;\n    }\n}\n/**\n * There are different ways to inject scriptlets (\"push\" vs \"pull\").\n * This function should decide based on the environment what to use:\n *\n * 1) \"Pushing\" means the adblocker will listen on \"onCommitted\" events\n *    and then execute scripts by running the tabs.executeScript API.\n * 2) \"Pulling\" means the adblocker will inject a content script, which\n *    runs before the page loads (and on the DOM changes), fetches\n *    scriplets from the background and runs them.\n *\n * Note:\n * - the \"push\" model requires permission to the webNavigation API.\n *   If that is not available, the implementation will fall back to the\n *   \"pull\" model, which does not have this requirement.\n */\nfunction usePushScriptsInjection() {\n    // There is no fundamental reason why it should not work on Firefox,\n    // but given that there are no known issues with Firefox, let's keep\n    // the old, proven technique until there is evidence that changes\n    // are needed.\n    //\n    // Take YouTube as an example: on Chrome (or forks like Edge), the adblocker\n    // will sometimes fail to block ads if you reload the page multiple times;\n    // on Firefox, the same steps do not seem to trigger any ads.\n    return !isFirefox();\n}\nconst USE_PUSH_SCRIPTS_INJECTION = usePushScriptsInjection();\n/**\n * Create an instance of `Request` from WebRequest details.\n */\nexport function fromWebRequestDetails(details) {\n    const sourceUrl = details.initiator || details.originUrl || details.documentUrl;\n    return Request.fromRawDetails(sourceUrl\n        ? {\n            _originalRequestDetails: details,\n            requestId: details.requestId,\n            sourceUrl,\n            tabId: details.tabId,\n            type: details.type,\n            url: details.url,\n        }\n        : {\n            _originalRequestDetails: details,\n            requestId: details.requestId,\n            tabId: details.tabId,\n            type: details.type,\n            url: details.url,\n        });\n}\n/**\n * Helper used when injecting custom CSP headers to update `responseHeaders`.\n */\nexport function updateResponseHeadersWithCSP(details, policies) {\n    if (policies === undefined) {\n        return {};\n    }\n    let responseHeaders = details.responseHeaders || [];\n    const CSP_HEADER_NAME = 'content-security-policy';\n    // Collect existing CSP headers from response\n    responseHeaders.forEach(({ name, value }) => {\n        if (name.toLowerCase() === CSP_HEADER_NAME) {\n            policies += `; ${value}`;\n        }\n    });\n    // Remove all CSP headers from response\n    responseHeaders = responseHeaders.filter(({ name }) => name.toLowerCase() !== CSP_HEADER_NAME);\n    // Add updated CSP header\n    responseHeaders.push({ name: CSP_HEADER_NAME, value: policies });\n    return { responseHeaders };\n}\n/**\n * Enable stream HTML filter on request `id` using `rules`.\n */\nexport function filterRequestHTML(filterResponseData, { id }, rules) {\n    // Create filter to observe loading of resource\n    const filter = filterResponseData(id);\n    const decoder = new TextDecoder();\n    const encoder = new TextEncoder();\n    const htmlFilter = new StreamingHtmlFilter(rules);\n    const teardown = (event) => {\n        // Before disconnecting our streaming filter, we need to be extra careful\n        // and make sure that no data remains in either our streaming `TextDecoder`\n        // instance or the HTML filterer.\n        //\n        // In case any data remains, we write it to filter.\n        try {\n            const remaining = htmlFilter.write(decoder.decode()) + htmlFilter.flush();\n            if (remaining.length !== 0) {\n                filter.write(encoder.encode(remaining));\n            }\n        }\n        catch (ex) {\n            // If we reach this point, there is probably no way we can recover...\n            console.error('Failed to flush HTML filterer', ex);\n        }\n        // If latest event had some data attached (i.e. 'ondata' event), we make\n        // sure to flush it through the filterer before disconnecting.\n        if (event.data !== undefined) {\n            filter.write(event.data);\n        }\n        // Disconnect streaming filter.\n        filter.disconnect();\n    };\n    filter.ondata = (event) => {\n        // On any chunk of data we implementa very fast UTF-8 validity check to make\n        // sure that we will be able to decode it. Note that in theory it should be\n        // possible that a chunk ends on the boundary of a multi-byte UTF-8 code and\n        // this check would fail?\n        if (isUTF8(new Uint8Array(event.data)) === false) {\n            return teardown(event);\n        }\n        try {\n            filter.write(encoder.encode(htmlFilter.write(decoder.decode(event.data, { stream: true }))));\n        }\n        catch (ex) {\n            // If we fail to decode a chunk, we need to be extra conservative and stop\n            // listening to streaming response. Teardown takes care of flushing any\n            // data remaining in the pipeline and disconnecting the listener.\n            return teardown(event);\n        }\n    };\n    filter.onstop = () => {\n        teardown({});\n    };\n}\n/**\n * This abstraction takes care of blocking in one instance of `browser` (in\n * practice this would be `chrome` or `browser` global in the WebExtension\n * context).\n */\nexport class BlockingContext {\n    constructor(browser, blocker) {\n        var _a;\n        this.browser = browser;\n        this.blocker = blocker;\n        this.onBeforeRequest = (details) => blocker.onBeforeRequest(browser, details);\n        this.onHeadersReceived = (details) => blocker.onHeadersReceived(browser, details);\n        this.onRuntimeMessage = (msg, sender) => blocker.onRuntimeMessage(browser, msg, sender);\n        if (this.blocker.config.enablePushInjectionsOnNavigationEvents === true &&\n            USE_PUSH_SCRIPTS_INJECTION) {\n            if ((_a = this.browser.webNavigation) === null || _a === void 0 ? void 0 : _a.onCommitted) {\n                this.onCommittedHandler = (details) => blocker.onCommittedHandler(browser, details);\n            }\n            else {\n                console.warn('Consider adding the \"webNavigation\" permission in the manifest to improve the reliability of the adblocker. ' +\n                    'If you do not want to see this warning, turn off the \"enablePushInjectionsOnNavigationEvents\" flag.');\n            }\n        }\n    }\n    enable() {\n        if (this.blocker.config.loadNetworkFilters === true && this.browser.webRequest !== undefined) {\n            this.browser.webRequest.onBeforeRequest.addListener(this.onBeforeRequest, { urls: ['<all_urls>'] }, ['blocking']);\n            this.browser.webRequest.onHeadersReceived.addListener(this.onHeadersReceived, { urls: ['<all_urls>'], types: ['main_frame'] }, ['blocking', 'responseHeaders']);\n        }\n        // Start listening to messages coming from the content-script\n        if (this.blocker.config.loadCosmeticFilters === true &&\n            this.browser.runtime !== undefined &&\n            this.browser.runtime.onMessage !== undefined) {\n            this.browser.runtime.onMessage.addListener(this.onRuntimeMessage);\n        }\n        if (this.onCommittedHandler) {\n            this.browser.webNavigation.onCommitted.addListener(this.onCommittedHandler);\n        }\n    }\n    disable() {\n        if (this.browser.webRequest !== undefined) {\n            this.browser.webRequest.onBeforeRequest.removeListener(this.onBeforeRequest);\n            this.browser.webRequest.onHeadersReceived.removeListener(this.onHeadersReceived);\n        }\n        if (this.browser.runtime !== undefined && this.browser.runtime.onMessage !== undefined) {\n            this.browser.runtime.onMessage.removeListener(this.onRuntimeMessage);\n        }\n        if (this.onCommittedHandler) {\n            this.browser.webNavigation.onCommitted.removeListener(this.onCommittedHandler);\n        }\n    }\n    get pushInjectionsActive() {\n        return this.onCommittedHandler !== undefined;\n    }\n}\n/**\n * Wrap `FiltersEngine` into a WebExtension-friendly helper class. It exposes\n * methods to interface with WebExtension APIs needed to block ads.\n */\nexport class WebExtensionBlocker extends FiltersEngine {\n    constructor() {\n        super(...arguments);\n        this.contexts = new WeakMap();\n        this.handleRuntimeMessage = async (browser, msg, sender, sendResponse) => {\n            var _a, _b;\n            const promises = [];\n            // Make sure we only listen to messages coming from our content-script\n            // based on the value of `action`.\n            if (msg.action !== 'getCosmeticsFilters') {\n                return;\n            }\n            if (sender.tab === undefined) {\n                throw new Error('required \"sender.tab\" information is not available');\n            }\n            if (sender.tab.id === undefined) {\n                throw new Error('required \"sender.tab.id\" information is not available');\n            }\n            if (sender.frameId === undefined) {\n                throw new Error('required \"sender.frameId\" information is not available');\n            }\n            // Extract hostname from sender's URL\n            const { url = '', frameId } = sender;\n            const parsed = parse(url);\n            const hostname = parsed.hostname || '';\n            const domain = parsed.domain || '';\n            // Once per tab/page load we inject base stylesheets. These are always\n            // the same for all frames of a given page because they do not depend on\n            // a particular domain and cannot be cancelled using unhide rules.\n            // Because of this, we specify `allFrames: true` when injecting them so\n            // that we do not need to perform this operation for sub-frames.\n            if (frameId === 0 && msg.lifecycle === 'start') {\n                const { active, styles } = this.getCosmeticsFilters({\n                    domain,\n                    hostname,\n                    url,\n                    classes: msg.classes,\n                    hrefs: msg.hrefs,\n                    ids: msg.ids,\n                    // This needs to be done only once per tab\n                    getBaseRules: true,\n                    getInjectionRules: false,\n                    getExtendedRules: false,\n                    getRulesFromDOM: false,\n                    getRulesFromHostname: false,\n                    callerContext: {\n                        tabId: (_a = sender.tab) === null || _a === void 0 ? void 0 : _a.id,\n                        frameId: sender.frameId,\n                    },\n                });\n                if (active === false) {\n                    return;\n                }\n                promises.push(this.injectStylesWebExtension(browser, styles, {\n                    tabId: sender.tab.id,\n                    allFrames: true,\n                }));\n            }\n            // Separately, requests cosmetics which depend on the page it self\n            // (either because of the hostname or content of the DOM). Content script\n            // logic is responsible for returning information about lists of classes,\n            // ids and hrefs observed in the DOM. MutationObserver is also used to\n            // make sure we can react to changes.\n            {\n                const { active, styles, scripts, extended } = this.getCosmeticsFilters({\n                    domain,\n                    hostname,\n                    url,\n                    classes: msg.classes,\n                    hrefs: msg.hrefs,\n                    ids: msg.ids,\n                    // This needs to be done only once per frame\n                    getBaseRules: false,\n                    getInjectionRules: msg.lifecycle === 'start',\n                    getExtendedRules: msg.lifecycle === 'start',\n                    getRulesFromHostname: msg.lifecycle === 'start',\n                    // This will be done every time we get information about DOM mutation\n                    getRulesFromDOM: msg.lifecycle === 'dom-update',\n                    callerContext: {\n                        tabId: (_b = sender.tab) === null || _b === void 0 ? void 0 : _b.id,\n                        frameId: sender.frameId,\n                    },\n                });\n                if (active === false) {\n                    return;\n                }\n                promises.push(this.injectStylesWebExtension(browser, styles, { tabId: sender.tab.id, frameId }));\n                // Inject scripts from content script\n                if (scripts.length !== 0 && !this.pushInjectionsActive(browser)) {\n                    sendResponse({\n                        active,\n                        extended,\n                        scripts,\n                        styles: '',\n                    });\n                }\n            }\n            await Promise.all(promises);\n        };\n        /**\n         * Deal with request cancellation (`{ cancel: true }`) and redirection (`{ redirectUrl: '...' }`).\n         */\n        this.onBeforeRequest = (browser, details) => {\n            const request = fromWebRequestDetails(details);\n            if (this.config.guessRequestTypeFromUrl === true && request.type === 'other') {\n                request.guessTypeOfRequest();\n            }\n            if (request.isMainFrame()) {\n                this.performHTMLFiltering(browser, request);\n                return {};\n            }\n            const { redirect, match } = this.match(request);\n            if (redirect !== undefined) {\n                return { redirectUrl: redirect.dataUrl };\n            }\n            else if (match === true) {\n                return { cancel: true };\n            }\n            return {};\n        };\n        this.onHeadersReceived = (_, details) => {\n            return updateResponseHeadersWithCSP(details, this.getCSPDirectives(fromWebRequestDetails(details)));\n        };\n        this.onRuntimeMessage = (browser, msg, sender) => {\n            return new Promise((resolve, reject) => {\n                this.handleRuntimeMessage(browser, msg, sender, resolve)\n                    .catch(reject)\n                    .finally(() => resolve({}));\n            });\n        };\n    }\n    // ----------------------------------------------------------------------- //\n    // Helpers to enable and disable blocking for 'browser'\n    // ----------------------------------------------------------------------- //\n    enableBlockingInBrowser(browser) {\n        let context = this.contexts.get(browser);\n        if (context !== undefined) {\n            return context;\n        }\n        // Create new blocking context for `browser`\n        context = new BlockingContext(browser, this);\n        this.contexts.set(browser, context);\n        context.enable();\n        return context;\n    }\n    disableBlockingInBrowser(browser) {\n        const context = this.contexts.get(browser);\n        if (context === undefined) {\n            throw new Error('Trying to disable blocking which was not enabled');\n        }\n        this.contexts.delete(browser);\n        context.disable();\n    }\n    onCommittedHandler(browser, details) {\n        const { hostname, domain } = parse(details.url);\n        if (!hostname) {\n            return;\n        }\n        // Find the scriptlets to run and execute them as soon as possible.\n        //\n        // If possible, everything in this path should be kept synchronously,\n        // since the scriptlets will attempt to patch the website while it is\n        // already loading. Every additional asynchronous step increases the risk\n        // of losing the race (i.e. that the patching is too late to have an effect)\n        const { active, scripts } = this.getCosmeticsFilters({\n            url: details.url,\n            hostname,\n            domain: domain || '',\n            getBaseRules: false,\n            getInjectionRules: true,\n            getExtendedRules: false,\n            getRulesFromDOM: false,\n            getRulesFromHostname: true,\n            callerContext: {\n                tabId: details.tabId,\n                frameId: details.frameId,\n            },\n        });\n        if (active === false) {\n            return;\n        }\n        if (scripts.length > 0) {\n            this.executeScriptlets(browser, details, scripts);\n        }\n    }\n    isBlockingEnabled(browser) {\n        return this.contexts.has(browser);\n    }\n    pushInjectionsActive(browser) {\n        const context = this.contexts.get(browser);\n        if (!context) {\n            // This means the browser instance is not controlled by the library directly.\n            // For instance, if there is another wrapping layer on top (e.g. Ghostery).\n            return false;\n        }\n        return context.pushInjectionsActive;\n    }\n    // ----------------------------------------------------------------------- //\n    // WebExtensionBlocker-specific additions to FiltersEngine\n    //\n    // Note: some of these methods internally require access to the 'browser'\n    // global in order to perform their function. Because WebExtensionBlocker can\n    // be registered in multiple ones (in theory), we do not want to depend either\n    // on the global object, or a single instance of 'browser' stored internally\n    // (except as part of a BlockingContext which binds one 'browser' object with\n    // a WebExtensionBlocker object to perform blocking in this context), so an\n    // extra 'browser' argument is often needed.\n    // ----------------------------------------------------------------------- //\n    /**\n     * This methods takes care of optionally performing HTML filtering.\n     *\n     * This can only be done if:\n     * 1. Request is 'main_frame'\n     * 2. `enableHtmlFiltering` is set to `true`.\n     * 3. `browser.webRequest.filterResponseData` (Firefox only!).\n     * 4. `TextEncoder` and `TextDecoder` are available.\n     */\n    performHTMLFiltering(browser, request) {\n        if (this.config.enableHtmlFiltering === true &&\n            browser.webRequest !== undefined &&\n            browser.webRequest.filterResponseData !== undefined &&\n            request.isMainFrame() === true &&\n            typeof TextDecoder !== 'undefined' &&\n            typeof TextEncoder !== 'undefined') {\n            const htmlFilters = this.getHtmlFilters(request);\n            if (htmlFilters.length !== 0) {\n                filterRequestHTML(browser.webRequest.filterResponseData, request, htmlFilters);\n            }\n        }\n    }\n    async injectStylesWebExtension(browser, styles, { tabId, frameId, allFrames = false, }) {\n        // Abort if stylesheet is empty.\n        if (styles.length === 0) {\n            return;\n        }\n        // Abort if `this.browser.tabs` is not available.\n        if (browser.tabs === undefined) {\n            throw new Error('required \"tabs\" API is not defined');\n        }\n        // Abort if `this.browser.tabs.insertCSS` is not available.\n        if (browser.tabs.insertCSS === undefined) {\n            throw new Error('required \"tabs.insertCSS\" API is not defined');\n        }\n        // Proceed with stylesheet injection.\n        return browser.tabs.insertCSS(tabId, frameId\n            ? {\n                allFrames,\n                code: styles,\n                cssOrigin: 'user',\n                frameId,\n                matchAboutBlank: true,\n                runAt: 'document_start',\n            }\n            : {\n                allFrames,\n                code: styles,\n                cssOrigin: 'user',\n                matchAboutBlank: true,\n                runAt: 'document_start',\n            });\n    }\n    executeScriptlets(browser, details, scripts) {\n        // Dynamically injected scripts scripts can be difficult to find later in\n        // the debugger. Console logs simplifies setting up breakpoints if needed.\n        let debugMarker;\n        if (this.config.debug) {\n            debugMarker = (text) => `console.log('[ADBLOCKER-DEBUG]:', ${JSON.stringify(text)});`;\n        }\n        else {\n            debugMarker = () => '';\n        }\n        // the scriptlet code that contains patches for the website\n        const codeRunningInPage = `(function(){\n${debugMarker('run scriptlets (executing in \"page world\")')}\n${scripts.join('\\n\\n')}}\n)()`;\n        // wrapper to break the \"isolated world\" so that the patching operates\n        // on the website, not on the content script's isolated environment.\n        const codeRunningInContentScript = `\n(function(code) {\n    ${debugMarker('run injection wrapper (executing in \"content script world\")')}\n    var script;\n    try {\n      script = document.createElement('script');\n      script.appendChild(document.createTextNode(decodeURIComponent(code)));\n      (document.head || document.documentElement).appendChild(script);\n    } catch (ex) {\n      console.error('Failed to run script', ex);\n    }\n    if (script) {\n        if (script.parentNode) {\n          script.parentNode.removeChild(script);\n        }\n        script.textContent = '';\n    }\n})(\\`${encodeURIComponent(codeRunningInPage)}\\`);`;\n        browser.tabs\n            .executeScript(details.tabId, {\n            code: codeRunningInContentScript,\n            runAt: 'document_start',\n            frameId: details.frameId,\n            matchAboutBlank: true,\n        })\n            .catch((err) => {\n            console.error('Failed to inject scriptlets', err);\n        });\n    }\n}\n// Re-export symbols from @cliqz/adblocker\nexport * from '@cliqz/adblocker';\n//# sourceMappingURL=index.js.map"],"names":["USE_PUSH_SCRIPTS_INJECTION","navigator","userAgent","indexOf","e","isFirefox","fromWebRequestDetails","details","sourceUrl","initiator","originUrl","documentUrl","Request","fromRawDetails","_originalRequestDetails","requestId","tabId","type","url","updateResponseHeadersWithCSP","policies","undefined","responseHeaders","CSP_HEADER_NAME","forEach","name","value","toLowerCase","filter","push","filterRequestHTML","filterResponseData","id","rules","decoder","TextDecoder","encoder","TextEncoder","htmlFilter","StreamingHtmlFilter","teardown","event","remaining","write","decode","flush","length","encode","ex","console","error","data","disconnect","ondata","isUTF8","Uint8Array","stream","onstop","BlockingContext","constructor","browser","blocker","_a","this","onBeforeRequest","onHeadersReceived","onRuntimeMessage","msg","sender","config","enablePushInjectionsOnNavigationEvents","webNavigation","onCommitted","onCommittedHandler","warn","enable","loadNetworkFilters","webRequest","addListener","urls","types","loadCosmeticFilters","runtime","onMessage","disable","removeListener","pushInjectionsActive","WebExtensionBlocker","FiltersEngine","super","arguments","contexts","WeakMap","handleRuntimeMessage","async","sendResponse","_b","promises","action","tab","Error","frameId","parsed","parse","hostname","domain","lifecycle","active","styles","getCosmeticsFilters","classes","hrefs","ids","getBaseRules","getInjectionRules","getExtendedRules","getRulesFromDOM","getRulesFromHostname","callerContext","injectStylesWebExtension","allFrames","scripts","extended","Promise","all","request","guessRequestTypeFromUrl","guessTypeOfRequest","isMainFrame","performHTMLFiltering","redirect","match","redirectUrl","dataUrl","cancel","_","getCSPDirectives","resolve","reject","catch","finally","enableBlockingInBrowser","context","get","set","disableBlockingInBrowser","delete","executeScriptlets","isBlockingEnabled","has","enableHtmlFiltering","htmlFilters","getHtmlFilters","tabs","insertCSS","code","cssOrigin","matchAboutBlank","runAt","debugMarker","debug","text","JSON","stringify","codeRunningInPage","join","codeRunningInContentScript","encodeURIComponent","executeScript","err"],"mappings":"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"}