{"version":3,"file":"adblocker.umd.min.js","sources":["esm/index.js"],"sourcesContent":["/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport * as electron from 'electron';\nimport { parse } from 'tldts-experimental';\nimport { FiltersEngine, Request } from '@cliqz/adblocker';\n// import { PRELOAD_PATH } from './preload_path.js';\nconst { ipcMain } = electron;\n// https://stackoverflow.com/questions/48854265/why-do-i-see-an-electron-security-warning-after-updating-my-electron-project-t\nprocess.env['ELECTRON_DISABLE_SECURITY_WARNINGS'] = 'true';\n/**\n * Create an instance of `Request` from `Electron.OnBeforeRequestDetails`.\n */\nexport function fromElectronDetails(details) {\n    const { id, url, resourceType, referrer, webContentsId } = details;\n    return Request.fromRawDetails(webContentsId\n        ? {\n            _originalRequestDetails: details,\n            requestId: `${id}`,\n            sourceUrl: referrer,\n            tabId: webContentsId,\n            type: (resourceType || 'other'),\n            url,\n        }\n        : {\n            _originalRequestDetails: details,\n            requestId: `${id}`,\n            sourceUrl: referrer,\n            type: (resourceType || 'other'),\n            url,\n        });\n}\n/**\n * This abstraction takes care of blocking in one instance of `Electron.Session`.\n */\nexport class BlockingContext {\n    constructor(session, blocker) {\n        this.session = session;\n        this.blocker = blocker;\n        this.onBeforeRequest = (details, callback) => blocker.onBeforeRequest(details, callback);\n        this.onGetCosmeticFiltersFirst = (event, url) => blocker.onGetCosmeticFiltersFirst(event, url);\n        this.onGetCosmeticFiltersUpdated = (event, url, msg) => blocker.onGetCosmeticFiltersUpdated(event, url, msg);\n        this.onHeadersReceived = (details, callback) => blocker.onHeadersReceived(details, callback);\n        this.onIsMutationObserverEnabled = (event) => blocker.onIsMutationObserverEnabled(event);\n    }\n    enable() {\n        if (this.blocker.config.loadCosmeticFilters === true) {\n            // this.session.setPreloads(this.session.getPreloads().concat([PRELOAD_PATH]));\n            // ipcMain.on('get-cosmetic-filters-first', this.onGetCosmeticFiltersFirst);\n            // ipcMain.on('get-cosmetic-filters', this.onGetCosmeticFiltersUpdated);\n            // ipcMain.on('is-mutation-observer-enabled', this.onIsMutationObserverEnabled);\n        }\n        if (this.blocker.config.loadNetworkFilters === true) {\n            this.session.webRequest.onHeadersReceived({ urls: ['<all_urls>'] }, this.onHeadersReceived);\n            this.session.webRequest.onBeforeRequest({ urls: ['<all_urls>'] }, this.onBeforeRequest);\n        }\n    }\n    disable() {\n        if (this.blocker.config.loadNetworkFilters === true) {\n            // NOTE - there is currently no support in Electron for multiple\n            // webRequest listeners registered for the same event. This means that\n            // adblocker's listeners can be overriden by other ones in the same\n            // application (or that the adblocker can override another listener\n            // registered previously). Because of this, the only way to disable the\n            // adblocker is to remove all listeners for the events we are interested\n            // in. In the future, we should consider implementing a webRequest\n            // pipeline allowing to register multiple listeners for the same event.\n            this.session.webRequest.onHeadersReceived(null);\n            this.session.webRequest.onBeforeRequest(null);\n        }\n        if (this.blocker.config.loadCosmeticFilters === true) {\n            // this.session.setPreloads(this.session.getPreloads().filter((p) => p !== PRELOAD_PATH));\n            ipcMain.removeListener('get-cosmetic-filters', this.onGetCosmeticFiltersUpdated);\n        }\n    }\n}\n/**\n * Wrap `FiltersEngine` into a Electron-friendly helper class. It exposes\n * methods to interface with Electron APIs needed to block ads.\n */\nexport class ElectronBlocker extends FiltersEngine {\n    constructor() {\n        super(...arguments);\n        this.contexts = new WeakMap();\n        // ----------------------------------------------------------------------- //\n        // ElectronBlocker-specific additions to FiltersEngine\n        // ----------------------------------------------------------------------- //\n        this.onIsMutationObserverEnabled = (event) => {\n            event.returnValue = this.config.enableMutationObserver;\n        };\n        this.onGetCosmeticFiltersFirst = (event, url) => {\n            // Extract hostname from sender's URL\n            const parsed = parse(url);\n            const hostname = parsed.hostname || '';\n            const domain = parsed.domain || '';\n            const { active, styles, scripts, extended } = this.getCosmeticsFilters({\n                domain,\n                hostname,\n                url,\n                // This needs to be done only once per frame\n                getBaseRules: true,\n                getInjectionRules: true,\n                getExtendedRules: true,\n                getRulesFromHostname: true,\n                getRulesFromDOM: false, // Only done on updates (see `onGetCosmeticFiltersUpdated`)\n                callerContext: {\n                    frameId: event.frameId,\n                    processId: event.processId,\n                },\n            });\n            if (active === false) {\n                event.returnValue = null;\n                return;\n            }\n            // Inject custom stylesheets\n            this.injectStyles(event.sender, styles);\n            event.sender.send('get-cosmetic-filters-response', {\n                active,\n                extended,\n                styles: '',\n            });\n            // to execute Inject scripts synchronously, simply return scripts to renderer.\n            event.returnValue = scripts;\n        };\n        this.onGetCosmeticFiltersUpdated = (event, url, msg) => {\n            // Extract hostname from sender's URL\n            const parsed = parse(url);\n            const hostname = parsed.hostname || '';\n            const domain = parsed.domain || '';\n            const { active, styles, extended } = this.getCosmeticsFilters({\n                domain,\n                hostname,\n                url,\n                classes: msg.classes,\n                hrefs: msg.hrefs,\n                ids: msg.ids,\n                // Only done on first load in the frame, disable for updates\n                getBaseRules: false,\n                getInjectionRules: false,\n                getExtendedRules: false,\n                getRulesFromHostname: false,\n                // This will be done every time we get information about DOM mutation\n                getRulesFromDOM: true,\n                callerContext: {\n                    frameId: event.frameId,\n                    processId: event.processId,\n                    lifecycle: msg.lifecycle,\n                },\n            });\n            if (active === false) {\n                return;\n            }\n            // Inject custom stylesheets\n            this.injectStyles(event.sender, styles);\n            // Inject scripts from content script\n            event.sender.send('get-cosmetic-filters-response', {\n                active,\n                extended,\n                styles: '',\n            });\n        };\n        this.onHeadersReceived = (details, callback) => {\n            const CSP_HEADER_NAME = 'content-security-policy';\n            const policies = [];\n            const responseHeaders = details.responseHeaders || {};\n            if (details.resourceType === 'mainFrame' || details.resourceType === 'subFrame') {\n                const rawCSP = this.getCSPDirectives(fromElectronDetails(details));\n                if (rawCSP !== undefined) {\n                    policies.push(...rawCSP.split(';').map((csp) => csp.trim()));\n                    // Collect existing CSP headers from response\n                    for (const [name, values] of Object.entries(responseHeaders)) {\n                        if (name.toLowerCase() === CSP_HEADER_NAME) {\n                            policies.push(...values);\n                            delete responseHeaders[name];\n                        }\n                    }\n                    responseHeaders[CSP_HEADER_NAME] = [policies.join(';')];\n                    callback({ responseHeaders });\n                    return;\n                }\n            }\n            callback({});\n        };\n        this.onBeforeRequest = (details, callback) => {\n            const request = fromElectronDetails(details);\n            if (this.config.guessRequestTypeFromUrl === true && request.type === 'other') {\n                request.guessTypeOfRequest();\n            }\n            if (request.isMainFrame()) {\n                callback({});\n                return;\n            }\n            const { redirect, match } = this.match(request);\n            if (redirect) {\n                callback({ redirectURL: redirect.dataUrl });\n            }\n            else if (match) {\n                callback({ cancel: true });\n            }\n            else {\n                callback({});\n            }\n        };\n    }\n    // ----------------------------------------------------------------------- //\n    // Helpers to enable and disable blocking for 'browser'\n    // ----------------------------------------------------------------------- //\n    enableBlockingInSession(session) {\n        let context = this.contexts.get(session);\n        if (context !== undefined) {\n            return context;\n        }\n        // Create new blocking context for `session`\n        context = new BlockingContext(session, this);\n        this.contexts.set(session, context);\n        context.enable();\n        return context;\n    }\n    disableBlockingInSession(session) {\n        const context = this.contexts.get(session);\n        if (context === undefined) {\n            throw new Error('Trying to disable blocking which was not enabled');\n        }\n        this.contexts.delete(session);\n        context.disable();\n    }\n    isBlockingEnabled(session) {\n        return this.contexts.has(session);\n    }\n    injectStyles(sender, styles) {\n        if (styles.length > 0) {\n            sender.insertCSS(styles, {\n                cssOrigin: 'user',\n            });\n        }\n    }\n}\n// re-export @cliqz/adblocker symbols for convenience\nexport * from '@cliqz/adblocker';\n//# sourceMappingURL=index.js.map"],"names":["ipcMain","electron","fromElectronDetails","details","id","url","resourceType","referrer","webContentsId","Request","fromRawDetails","_originalRequestDetails","requestId","sourceUrl","tabId","type","process","env","BlockingContext","constructor","session","blocker","this","onBeforeRequest","callback","onGetCosmeticFiltersFirst","event","onGetCosmeticFiltersUpdated","msg","onHeadersReceived","onIsMutationObserverEnabled","enable","config","loadCosmeticFilters","loadNetworkFilters","webRequest","urls","disable","removeListener","ElectronBlocker","FiltersEngine","super","arguments","contexts","WeakMap","returnValue","enableMutationObserver","parsed","parse","hostname","domain","active","styles","scripts","extended","getCosmeticsFilters","getBaseRules","getInjectionRules","getExtendedRules","getRulesFromHostname","getRulesFromDOM","callerContext","frameId","processId","injectStyles","sender","send","classes","hrefs","ids","lifecycle","CSP_HEADER_NAME","policies","responseHeaders","rawCSP","getCSPDirectives","undefined","push","split","map","csp","trim","name","values","Object","entries","toLowerCase","join","request","guessRequestTypeFromUrl","guessTypeOfRequest","isMainFrame","redirect","match","redirectURL","dataUrl","cancel","enableBlockingInSession","context","get","set","disableBlockingInSession","Error","delete","isBlockingEnabled","has","length","insertCSS","cssOrigin"],"mappings":"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"}