{"version":3,"file":"content-script.iife.js","sources":["../../adblocker-extended-selectors/dist/esm/parse.js","../../adblocker-extended-selectors/dist/esm/eval.js","../../adblocker-extended-selectors/dist/esm/extended.js","../../adblocker-content/dist/esm/index.js","../../adblocker-webextension-cosmetics/dist/esm/index.js","../../content-script.ts"],"sourcesContent":["/*!\n * Based on parsel. Extended by Rémi Berson for Ghostery (2021).\n * https://github.com/LeaVerou/parsel\n *\n * MIT License\n *\n * Copyright (c) 2020 Lea Verou\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nimport { isAST, isAtoms } from './types.js';\nexport const RECURSIVE_PSEUDO_CLASSES = new Set([\n    'any',\n    'dir',\n    'has',\n    'host-context',\n    'if',\n    'if-not',\n    'is',\n    'matches',\n    'not',\n    'where',\n]);\nconst TOKENS = {\n    attribute: /\\[\\s*(?:(?<namespace>\\*|[-\\w]*)\\|)?(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(?<caseSensitive>[iIsS])?\\s*)?\\]/gu,\n    id: /#(?<name>(?:[-\\w\\u{0080}-\\u{FFFF}]|\\\\.)+)/gu,\n    class: /\\.(?<name>(?:[-\\w\\u{0080}-\\u{FFFF}]|\\\\.)+)/gu,\n    comma: /\\s*,\\s*/g, // must be before combinator\n    combinator: /\\s*[\\s>+~]\\s*/g, // this must be after attribute\n    'pseudo-element': /::(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)(?:\\((?:¶*)\\))?/gu, // this must be before pseudo-class\n    'pseudo-class': /:(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)(?:\\((?<argument>¶*)\\))?/gu,\n    type: /(?:(?<namespace>\\*|[-\\w]*)\\|)?(?<name>[-\\w\\u{0080}-\\u{FFFF}]+)|\\*/gu, // this must be last\n};\nconst TOKENS_WITH_PARENS = new Set(['pseudo-class', 'pseudo-element']);\nconst TOKENS_WITH_STRINGS = new Set([...TOKENS_WITH_PARENS, 'attribute']);\nconst TRIM_TOKENS = new Set(['combinator', 'comma']);\nconst TOKENS_FOR_RESTORE = Object.assign({}, TOKENS);\nTOKENS_FOR_RESTORE['pseudo-element'] = RegExp(TOKENS['pseudo-element'].source.replace('(?<argument>¶*)', '(?<argument>.*?)'), 'gu');\nTOKENS_FOR_RESTORE['pseudo-class'] = RegExp(TOKENS['pseudo-class'].source.replace('(?<argument>¶*)', '(?<argument>.*)'), 'gu');\n// TODO - it feels like with some more typing shenanigans we could replace groups validation by generic logic in this function.\nfunction splitOnMatch(pattern, str) {\n    pattern.lastIndex = 0;\n    const match = pattern.exec(str);\n    if (match === null) {\n        return undefined;\n    }\n    const from = match.index - 1;\n    const content = match[0];\n    const before = str.slice(0, from + 1);\n    const after = str.slice(from + content.length + 1);\n    return [before, [content, match.groups || {}], after];\n}\nconst GRAMMAR = [\n    // attribute\n    (str) => {\n        const match = splitOnMatch(TOKENS.attribute, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name, operator, value, namespace, caseSensitive }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'attribute',\n                content,\n                length: content.length,\n                namespace,\n                caseSensitive,\n                pos: [],\n                name,\n                operator,\n                value,\n            },\n            after,\n        ];\n    },\n    // #id\n    (str) => {\n        const match = splitOnMatch(TOKENS.id, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'id',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n    // .class\n    (str) => {\n        const match = splitOnMatch(TOKENS.class, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'class',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n    // comma ,\n    (str) => {\n        const match = splitOnMatch(TOKENS.comma, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content], after] = match;\n        return [\n            before,\n            {\n                type: 'comma',\n                content,\n                length: content.length,\n                pos: [],\n            },\n            after,\n        ];\n    },\n    // combinator\n    (str) => {\n        const match = splitOnMatch(TOKENS.combinator, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content], after] = match;\n        return [\n            before,\n            {\n                type: 'combinator',\n                content,\n                length: content.length,\n                pos: [],\n            },\n            after,\n        ];\n    },\n    // pseudo-element\n    (str) => {\n        const match = splitOnMatch(TOKENS['pseudo-element'], str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'pseudo-element',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n    // pseudo-class\n    (str) => {\n        const match = splitOnMatch(TOKENS['pseudo-class'], str);\n        if (match === undefined) {\n            return undefined;\n        }\n        // TODO - here `argument` can be undefined and should be rejected?\n        const [before, [content, { name, argument }], after] = match;\n        if (name === undefined) {\n            return undefined;\n        }\n        return [\n            before,\n            {\n                type: 'pseudo-class',\n                content,\n                length: content.length,\n                pos: [],\n                name,\n                argument,\n                subtree: undefined,\n            },\n            after,\n        ];\n    },\n    // type\n    (str) => {\n        const match = splitOnMatch(TOKENS.type, str);\n        if (match === undefined) {\n            return undefined;\n        }\n        const [before, [content, { name, namespace }], after] = match;\n        return [\n            before,\n            {\n                type: 'type',\n                content,\n                length: content.length,\n                namespace,\n                pos: [],\n                name,\n            },\n            after,\n        ];\n    },\n];\nfunction tokenizeBy(text) {\n    if (!text) {\n        return [];\n    }\n    const strarr = [text];\n    for (const tokenizer of GRAMMAR) {\n        for (let i = 0; i < strarr.length; i++) {\n            const str = strarr[i];\n            if (typeof str === 'string') {\n                const match = tokenizer(str);\n                if (match !== undefined) {\n                    strarr.splice(i, 1, ...match.filter((a) => a.length !== 0));\n                }\n            }\n        }\n    }\n    let offset = 0;\n    for (const token of strarr) {\n        if (typeof token !== 'string') {\n            token.pos = [offset, offset + token.length];\n            if (TRIM_TOKENS.has(token.type)) {\n                token.content = token.content.trim() || ' ';\n            }\n        }\n        offset += token.length;\n    }\n    if (isAtoms(strarr)) {\n        return strarr;\n    }\n    // NOTE: here this means that parsing failed.\n    return [];\n}\nfunction restoreNested(tokens, strings, regex, types) {\n    // TODO - here from offsets in strings and tokens we should be able to find the exact spot without RegExp?\n    for (const str of strings) {\n        for (const token of tokens) {\n            if (types.has(token.type) && token.pos[0] < str.start && str.start < token.pos[1]) {\n                const content = token.content;\n                token.content = token.content.replace(regex, str.str);\n                if (token.content !== content) {\n                    // actually changed?\n                    // Re-evaluate groups\n                    TOKENS_FOR_RESTORE[token.type].lastIndex = 0;\n                    const match = TOKENS_FOR_RESTORE[token.type].exec(token.content);\n                    if (match !== null) {\n                        Object.assign(token, match.groups);\n                    }\n                }\n            }\n        }\n    }\n}\nexport function isEscaped(str, index) {\n    let backslashes = 0;\n    index -= 1;\n    while (index >= 0 && str[index] === '\\\\') {\n        backslashes += 1;\n        index -= 1;\n    }\n    return backslashes % 2 !== 0;\n}\nexport function gobbleQuotes(text, quote, start) {\n    // Find end of quote, taking care of ignoring escaped quotes\n    let end = start + 1;\n    while ((end = text.indexOf(quote, end)) !== -1 && isEscaped(text, end) === true) {\n        end += 1;\n    }\n    if (end === -1) {\n        // Opening quote without closing quote\n        return undefined;\n    }\n    return text.slice(start, end + 1);\n}\nexport function gobbleParens(text, start) {\n    let stack = 0;\n    for (let i = start; i < text.length; i++) {\n        const char = text[i];\n        if (char === '(') {\n            stack += 1;\n        }\n        else if (char === ')') {\n            if (stack > 0) {\n                stack -= 1;\n            }\n            else {\n                // Closing paren without opening paren\n                return undefined;\n            }\n        }\n        if (stack === 0) {\n            return text.slice(start, i + 1);\n        }\n    }\n    // Opening paren without closing paren\n    return undefined;\n}\nexport function replace(selector, replacement, opening, gobble) {\n    const strings = [];\n    let offset = 0;\n    while ((offset = selector.indexOf(opening, offset)) !== -1) {\n        const str = gobble(selector, offset);\n        if (str === undefined) {\n            break;\n        }\n        strings.push({ str, start: offset });\n        selector = `${selector.slice(0, offset + 1)}${replacement.repeat(str.length - 2)}${selector.slice(offset + str.length - 1)}`;\n        offset += str.length;\n    }\n    return [strings, selector];\n}\nexport function tokenize(selector) {\n    if (typeof selector !== 'string') {\n        return [];\n    }\n    // Prevent leading/trailing whitespace be interpreted as combinators\n    selector = selector.trim();\n    if (selector.length === 0) {\n        return [];\n    }\n    // Replace strings with whitespace strings (to preserve offsets)\n    const [doubleQuotes, selectorWithoutDoubleQuotes] = replace(selector, '§', '\"', (text, start) => gobbleQuotes(text, '\"', start));\n    const [singleQuotes, selectorWithoutQuotes] = replace(selectorWithoutDoubleQuotes, '§', \"'\", (text, start) => gobbleQuotes(text, \"'\", start));\n    // Now that strings are out of the way, extract parens and replace them with parens with whitespace (to preserve offsets)\n    const [parens, selectorWithoutParens] = replace(selectorWithoutQuotes, '¶', '(', gobbleParens);\n    // Now we have no nested structures and we can parse with regexes\n    const tokens = tokenizeBy(selectorWithoutParens);\n    // Now restore parens and strings in reverse order\n    restoreNested(tokens, parens, /\\(¶*\\)/, TOKENS_WITH_PARENS);\n    restoreNested(tokens, doubleQuotes, /\"§*\"/, TOKENS_WITH_STRINGS);\n    restoreNested(tokens, singleQuotes, /'§*'/, TOKENS_WITH_STRINGS);\n    return tokens;\n}\n// Convert a flat list of tokens into a tree of complex & compound selectors\nfunction nestTokens(tokens, { list = true } = {}) {\n    if (list === true && tokens.some((t) => t.type === 'comma')) {\n        const selectors = [];\n        const temp = [];\n        for (let i = 0; i < tokens.length; i += 1) {\n            const token = tokens[i];\n            if (token.type === 'comma') {\n                if (temp.length === 0) {\n                    throw new Error('Incorrect comma at ' + i);\n                }\n                const sub = nestTokens(temp, { list: false });\n                if (sub !== undefined) {\n                    selectors.push(sub);\n                }\n                temp.length = 0;\n            }\n            else {\n                temp.push(token);\n            }\n        }\n        if (temp.length === 0) {\n            throw new Error('Trailing comma');\n        }\n        else {\n            const sub = nestTokens(temp, { list: false });\n            if (sub !== undefined) {\n                selectors.push(sub);\n            }\n        }\n        return { type: 'list', list: selectors };\n    }\n    for (let i = tokens.length - 1; i >= 0; i--) {\n        const token = tokens[i];\n        if (token.type === 'combinator') {\n            const left = nestTokens(tokens.slice(0, i));\n            const right = nestTokens(tokens.slice(i + 1));\n            if (right === undefined) {\n                return undefined;\n            }\n            if (token.content !== ' ' &&\n                token.content !== '~' &&\n                token.content !== '+' &&\n                token.content !== '>') {\n                return undefined;\n            }\n            return {\n                type: 'complex',\n                combinator: token.content,\n                left,\n                right,\n            };\n        }\n    }\n    if (tokens.length === 0) {\n        return undefined;\n    }\n    if (isAST(tokens)) {\n        if (tokens.length === 1) {\n            return tokens[0];\n        }\n        // If we're here, there are no combinators, so it's just a list\n        return {\n            type: 'compound',\n            compound: [...tokens], // clone to avoid pointers messing up the AST\n        };\n    }\n    return undefined;\n}\n// Traverse an AST (or part thereof), in depth-first order\nfunction walk(node, callback, o, parent) {\n    if (node === undefined) {\n        return;\n    }\n    if (node.type === 'complex') {\n        walk(node.left, callback, o, node);\n        walk(node.right, callback, o, node);\n    }\n    else if (node.type === 'compound') {\n        for (const n of node.compound) {\n            walk(n, callback, o, node);\n        }\n    }\n    else if (node.type === 'pseudo-class' &&\n        node.subtree !== undefined &&\n        o !== undefined &&\n        o.type === 'pseudo-class' &&\n        o.subtree !== undefined) {\n        walk(node.subtree, callback, o, node);\n    }\n    callback(node, parent);\n}\n/**\n * Parse a CSS selector\n * @param selector {String} The selector to parse\n * @param options.recursive {Boolean} Whether to parse the arguments of pseudo-classes like :is(), :has() etc. Defaults to true.\n * @param options.list {Boolean} Whether this can be a selector list (A, B, C etc). Defaults to true.\n */\nexport function parse(selector, { recursive = true, list = true } = {}) {\n    const tokens = tokenize(selector);\n    if (tokens.length === 0) {\n        return undefined;\n    }\n    const ast = nestTokens(tokens, { list });\n    if (recursive === true) {\n        walk(ast, (node) => {\n            if (node.type === 'pseudo-class' &&\n                node.argument &&\n                node.name !== undefined &&\n                RECURSIVE_PSEUDO_CLASSES.has(node.name)) {\n                node.subtree = parse(node.argument, { recursive: true, list: true });\n            }\n        });\n    }\n    return ast;\n}\n//# sourceMappingURL=parse.js.map","/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport function matchPattern(pattern, text) {\n    // TODO - support 'm' RegExp argument\n    if (pattern.startsWith('/') && (pattern.endsWith('/') || pattern.endsWith('/i'))) {\n        let caseSensitive = true;\n        pattern = pattern.slice(1);\n        if (pattern.endsWith('/')) {\n            pattern = pattern.slice(0, -1);\n        }\n        else {\n            pattern = pattern.slice(0, -2);\n            caseSensitive = false;\n        }\n        return new RegExp(pattern, caseSensitive === false ? 'i' : undefined).test(text);\n    }\n    return text.includes(pattern);\n}\nexport function matches(element, selector) {\n    if (selector.type === 'id' ||\n        selector.type === 'class' ||\n        selector.type === 'type' ||\n        selector.type === 'attribute') {\n        return element.matches(selector.content);\n    }\n    else if (selector.type === 'list') {\n        return selector.list.some((s) => matches(element, s));\n    }\n    else if (selector.type === 'compound') {\n        return selector.compound.every((s) => matches(element, s));\n    }\n    else if (selector.type === 'pseudo-class') {\n        if (selector.name === 'has' || selector.name === 'if') {\n            // TODO - is this a querySelectorAll or matches here?\n            return (selector.subtree !== undefined && querySelectorAll(element, selector.subtree).length !== 0);\n        }\n        else if (selector.name === 'not') {\n            return selector.subtree !== undefined && matches(element, selector.subtree) === false;\n        }\n        else if (selector.name === 'has-text') {\n            const { argument } = selector;\n            if (argument === undefined) {\n                return false;\n            }\n            const text = element.textContent;\n            if (text === null) {\n                return false;\n            }\n            return matchPattern(argument, text);\n        }\n        else if (selector.name === 'min-text-length') {\n            const minLength = Number(selector.argument);\n            if (Number.isNaN(minLength) || minLength < 0) {\n                return false;\n            }\n            const text = element.textContent;\n            if (text === null) {\n                return false;\n            }\n            return text.length >= minLength;\n        }\n    }\n    return false;\n}\nexport function querySelectorAll(element, selector) {\n    const elements = [];\n    if (selector.type === 'id' ||\n        selector.type === 'class' ||\n        selector.type === 'type' ||\n        selector.type === 'attribute') {\n        elements.push(...element.querySelectorAll(selector.content));\n    }\n    else if (selector.type === 'list') {\n        for (const subSelector of selector.list) {\n            elements.push(...querySelectorAll(element, subSelector));\n        }\n    }\n    else if (selector.type === 'compound') {\n        // TODO - handling compound needs to be reworked...\n        // .cls:upward(1) for example will not work with this implementation.\n        // :upward is not about selecting, but transforming a set of nodes (i.e.\n        // uBO's transpose method).\n        if (selector.compound.length !== 0) {\n            elements.push(...querySelectorAll(element, selector.compound[0]).filter((e) => selector.compound.slice(1).every((s) => matches(e, s))));\n        }\n    }\n    else if (selector.type === 'complex') {\n        const elements2 = selector.left === undefined ? [element] : querySelectorAll(element, selector.left);\n        if (selector.combinator === ' ') {\n            for (const element2 of elements2) {\n                elements.push(...querySelectorAll(element2, selector.right));\n            }\n        }\n        else if (selector.combinator === '>') {\n            for (const element2 of elements2) {\n                for (const child of element2.children) {\n                    if (matches(child, selector.right) === true) {\n                        elements.push(child);\n                    }\n                }\n            }\n        }\n        else if (selector.combinator === '~') {\n            for (const element2 of elements2) {\n                let sibling = element2;\n                while ((sibling = sibling.nextElementSibling) !== null) {\n                    if (matches(sibling, selector.right) === true) {\n                        elements.push(sibling);\n                    }\n                }\n            }\n        }\n        else if (selector.combinator === '+') {\n            for (const element2 of elements2) {\n                const nextElementSibling = element2.nextElementSibling;\n                if (nextElementSibling !== null && matches(nextElementSibling, selector.right) === true) {\n                    elements.push(nextElementSibling);\n                }\n            }\n        }\n    }\n    else if (selector.type === 'pseudo-class') {\n        // if (selector.name === 'upward') {\n        //   let n = Number(selector.argument);\n        //   console.log('upward', selector, n);\n        //   if (Number.isNaN(n) === false) {\n        //     if (n >= 1 && n < 256) {\n        //       let ancestor: Element | null = element;\n        //       while (ancestor !== null && n > 0) {\n        //         ancestor = ancestor.parentElement;\n        //         n -= 1;\n        //       }\n        //       if (ancestor !== null && n === 0) {\n        //         elements.push(element);\n        //       }\n        //     }\n        //   } else if (selector.argument !== undefined) {\n        //     const parent = element.parentElement;\n        //     if (parent !== null) {\n        //       const ancestor = parent.closest(selector.argument);\n        //       if (ancestor !== null) {\n        //         elements.push(ancestor);\n        //       }\n        //     }\n        //   }\n        // } else {\n        for (const subElement of element.querySelectorAll('*')) {\n            if (matches(subElement, selector) === true) {\n                elements.push(subElement);\n            }\n        }\n        // }\n    }\n    return elements;\n}\n//# sourceMappingURL=eval.js.map","/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { tokenize, RECURSIVE_PSEUDO_CLASSES } from './parse.js';\nexport const EXTENDED_PSEUDO_CLASSES = new Set([\n    // '-abp-contains',\n    // '-abp-has',\n    // '-abp-properties',\n    'has',\n    'has-text',\n    'if',\n    // 'if-not',\n    // 'matches-css',\n    // 'matches-css-after',\n    // 'matches-css-before',\n    // 'min-text-length',\n    // 'nth-ancestor',\n    // 'upward',\n    // 'watch-attr',\n    // 'watch-attrs',\n    // 'xpath',\n]);\nexport const PSEUDO_CLASSES = new Set([\n    'active',\n    'any',\n    'any-link',\n    'blank',\n    'checked',\n    'default',\n    'defined',\n    'dir',\n    'disabled',\n    'empty',\n    'enabled',\n    'first',\n    'first-child',\n    'first-of-type',\n    'focus',\n    'focus-visible',\n    'focus-within',\n    'fullscreen',\n    'host',\n    'host-context',\n    'hover',\n    'in-range',\n    'indeterminate',\n    'invalid',\n    'is',\n    'lang',\n    'last-child',\n    'last-of-type',\n    'left',\n    'link',\n    'matches',\n    // NOTE: by default we consider `:not(...)` to be a normal CSS selector since,\n    // we are only interested in cases where the argument is an extended selector.\n    // If that is the case, it will still be detected as such.\n    'not',\n    'nth-child',\n    'nth-last-child',\n    'nth-last-of-type',\n    'nth-of-type',\n    'only-child',\n    'only-of-type',\n    'optional',\n    'out-of-range',\n    'placeholder-shown',\n    'read-only',\n    'read-write',\n    'required',\n    'right',\n    'root',\n    'scope',\n    'target',\n    'valid',\n    'visited',\n    'where',\n]);\n// NOTE: here we only need to list the pseudo-elements which can appear with a\n// single colon (e.g. :after or ::after are valid for backward compatibility\n// reasons). They can be misinterpreted as pseudo-classes by the tokenizer for\n// this reason.\nexport const PSEUDO_ELEMENTS = new Set(['after', 'before', 'first-letter', 'first-line']);\nexport var SelectorType;\n(function (SelectorType) {\n    SelectorType[SelectorType[\"Normal\"] = 0] = \"Normal\";\n    SelectorType[SelectorType[\"Extended\"] = 1] = \"Extended\";\n    SelectorType[SelectorType[\"Invalid\"] = 2] = \"Invalid\";\n})(SelectorType || (SelectorType = {}));\nexport function classifySelector(selector) {\n    // In most cases there is no pseudo-anything so we can quickly exit.\n    if (selector.indexOf(':') === -1) {\n        return SelectorType.Normal;\n    }\n    const tokens = tokenize(selector);\n    // Detect pseudo-classes\n    let foundSupportedExtendedSelector = false;\n    for (const token of tokens) {\n        if (token.type === 'pseudo-class') {\n            const { name } = token;\n            if (EXTENDED_PSEUDO_CLASSES.has(name) === true) {\n                foundSupportedExtendedSelector = true;\n            }\n            else if (PSEUDO_CLASSES.has(name) === false && PSEUDO_ELEMENTS.has(name) === false) {\n                return SelectorType.Invalid;\n            }\n            // Recursively\n            if (foundSupportedExtendedSelector === false &&\n                token.argument !== undefined &&\n                RECURSIVE_PSEUDO_CLASSES.has(name) === true) {\n                const argumentType = classifySelector(token.argument);\n                if (argumentType === SelectorType.Invalid) {\n                    return argumentType;\n                }\n                else if (argumentType === SelectorType.Extended) {\n                    foundSupportedExtendedSelector = true;\n                }\n            }\n        }\n    }\n    if (foundSupportedExtendedSelector === true) {\n        return SelectorType.Extended;\n    }\n    return SelectorType.Normal;\n}\n//# sourceMappingURL=extended.js.map","/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nconst SCRIPT_ID = 'cliqz-adblocker-script';\nconst IGNORED_TAGS = new Set(['br', 'head', 'link', 'meta', 'script', 'style', 's']);\nfunction debounce(fn, { waitFor, maxWait, }) {\n    let delayedTimer;\n    let maxWaitTimer;\n    const clear = () => {\n        clearTimeout(delayedTimer);\n        clearTimeout(maxWaitTimer);\n        delayedTimer = undefined;\n        maxWaitTimer = undefined;\n    };\n    const run = () => {\n        clear();\n        fn();\n    };\n    return [\n        () => {\n            if (maxWait > 0 && maxWaitTimer === undefined) {\n                maxWaitTimer = setTimeout(run, maxWait);\n            }\n            clearTimeout(delayedTimer);\n            delayedTimer = setTimeout(run, waitFor);\n        },\n        clear,\n    ];\n}\nfunction isElement(node) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType#node_type_constants\n    return node.nodeType === 1; // Node.ELEMENT_NODE;\n}\nfunction getElementsFromMutations(mutations) {\n    // Accumulate all nodes which were updated in `nodes`\n    const elements = [];\n    for (const mutation of mutations) {\n        if (mutation.type === 'attributes') {\n            if (isElement(mutation.target)) {\n                elements.push(mutation.target);\n            }\n        }\n        else if (mutation.type === 'childList') {\n            for (const addedNode of mutation.addedNodes) {\n                if (isElement(addedNode) && addedNode.id !== SCRIPT_ID) {\n                    elements.push(addedNode);\n                }\n            }\n        }\n    }\n    return elements;\n}\n/**\n * WARNING: this function should be self-contained and not rely on any global\n * symbol. That constraint needs to be fulfilled because this function can\n * potentially be injected in content-script (e.g.: see PuppeteerBlocker for\n * more details).\n */\nexport function extractFeaturesFromDOM(roots) {\n    // NOTE: This cannot be global as puppeteer needs to be able to serialize this function.\n    const ignoredTags = new Set(['br', 'head', 'link', 'meta', 'script', 'style', 's']);\n    const classes = new Set();\n    const hrefs = new Set();\n    const ids = new Set();\n    const seenElements = new Set();\n    for (const root of roots) {\n        for (const element of [\n            root,\n            ...root.querySelectorAll('[id]:not(html):not(body),[class]:not(html):not(body),[href]:not(html):not(body)'),\n        ]) {\n            // If one of root belongs to another root which is parent node of the one, querySelectorAll can return duplicates.\n            if (seenElements.has(element)) {\n                continue;\n            }\n            seenElements.add(element);\n            // Any conditions to filter this element out should be placed under this line:\n            if (ignoredTags.has(element.nodeName.toLowerCase())) {\n                continue;\n            }\n            // Update ids\n            const id = element.getAttribute('id');\n            if (typeof id === 'string') {\n                ids.add(id);\n            }\n            // Update classes\n            const classList = element.classList;\n            for (const classEntry of classList) {\n                classes.add(classEntry);\n            }\n            // Update href\n            const href = element.getAttribute('href');\n            if (typeof href === 'string') {\n                hrefs.add(href);\n            }\n        }\n    }\n    return {\n        classes: Array.from(classes),\n        hrefs: Array.from(hrefs),\n        ids: Array.from(ids),\n    };\n}\nexport class DOMMonitor {\n    constructor(cb) {\n        this.cb = cb;\n        this.knownIds = new Set();\n        this.knownHrefs = new Set();\n        this.knownClasses = new Set();\n        this.observer = null;\n    }\n    queryAll(window) {\n        this.cb({ type: 'elements', elements: [window.document.documentElement] });\n        this.handleUpdatedNodes([window.document.documentElement]);\n    }\n    start(window) {\n        if (this.observer === null && window.MutationObserver !== undefined) {\n            const nodes = new Set();\n            const handleUpdatedNodesCallback = () => {\n                this.handleUpdatedNodes(Array.from(nodes));\n                nodes.clear();\n            };\n            const [debouncedHandleUpdatedNodes, cancelHandleUpdatedNodes] = debounce(handleUpdatedNodesCallback, {\n                waitFor: 25,\n                maxWait: 1000,\n            });\n            this.observer = new window.MutationObserver((mutations) => {\n                getElementsFromMutations(mutations).forEach(nodes.add, nodes);\n                // Set a threshold to prevent websites continuously\n                // causing DOM mutations making the set being filled up infinitely.\n                if (nodes.size > 512) {\n                    cancelHandleUpdatedNodes();\n                    handleUpdatedNodesCallback();\n                }\n                else {\n                    debouncedHandleUpdatedNodes();\n                }\n            });\n            this.observer.observe(window.document.documentElement, {\n                // Monitor some attributes\n                attributes: true,\n                attributeFilter: ['class', 'id', 'href'],\n                childList: true,\n                subtree: true,\n            });\n        }\n    }\n    stop() {\n        if (this.observer !== null) {\n            this.observer.disconnect();\n            this.observer = null;\n        }\n    }\n    handleNewFeatures({ hrefs, ids, classes, }) {\n        const newIds = [];\n        const newClasses = [];\n        const newHrefs = [];\n        // Update ids\n        for (const id of ids) {\n            if (this.knownIds.has(id) === false) {\n                newIds.push(id);\n                this.knownIds.add(id);\n            }\n        }\n        for (const cls of classes) {\n            if (this.knownClasses.has(cls) === false) {\n                newClasses.push(cls);\n                this.knownClasses.add(cls);\n            }\n        }\n        for (const href of hrefs) {\n            if (this.knownHrefs.has(href) === false) {\n                newHrefs.push(href);\n                this.knownHrefs.add(href);\n            }\n        }\n        if (newIds.length !== 0 || newClasses.length !== 0 || newHrefs.length !== 0) {\n            this.cb({\n                type: 'features',\n                classes: newClasses,\n                hrefs: newHrefs,\n                ids: newIds,\n            });\n            return true;\n        }\n        return false;\n    }\n    handleUpdatedNodes(elements) {\n        if (elements.length !== 0) {\n            this.cb({\n                type: 'elements',\n                elements: elements.filter((e) => IGNORED_TAGS.has(e.nodeName.toLowerCase()) === false),\n            });\n            return this.handleNewFeatures(extractFeaturesFromDOM(elements));\n        }\n        return false;\n    }\n}\n/**\n * Wrap a self-executing script into a block of custom logic to remove the\n * script tag once execution is terminated. This can be useful to not leave\n * traces in the DOM after injections.\n */\nexport function autoRemoveScript(script) {\n    // Minified using 'terser'\n    return `try{${script}}catch(c){}!function(){var c=document.currentScript,e=c&&c.parentNode;e&&e.removeChild(c)}();`;\n    // Original:\n    //\n    //    try {\n    //      ${script}\n    //    } catch (ex) { }\n    //\n    //    (function() {\n    //      var currentScript = document.currentScript;\n    //      var parent = currentScript && currentScript.parentNode;\n    //\n    //      if (parent) {\n    //        parent.removeChild(currentScript);\n    //      }\n    //    })();\n}\nfunction insertNode(node, document) {\n    const parent = document.head || document.documentElement || document;\n    if (parent !== null) {\n        parent.appendChild(node);\n    }\n}\nfunction injectScriptlet(s, doc) {\n    const script = doc.createElement('script');\n    script.type = 'text/javascript';\n    script.id = SCRIPT_ID;\n    script.async = false;\n    script.appendChild(doc.createTextNode(autoRemoveScript(s)));\n    insertNode(script, doc);\n}\nfunction isFirefox(doc) {\n    var _a, _b, _c;\n    try {\n        return ((_c = (_b = (_a = doc.defaultView) === null || _a === void 0 ? void 0 : _a.navigator) === null || _b === void 0 ? void 0 : _b.userAgent) === null || _c === void 0 ? void 0 : _c.indexOf('Firefox')) !== -1;\n    }\n    catch (e) {\n        return false;\n    }\n}\nasync function injectScriptletFirefox(s, doc) {\n    const win = doc.defaultView;\n    const script = doc.createElement('script');\n    script.async = false;\n    script.id = SCRIPT_ID;\n    const blob = new win.Blob([autoRemoveScript(s)], { type: 'text/javascript; charset=utf-8' });\n    const url = win.URL.createObjectURL(blob);\n    // a hack for tests to that allows for async URL.createObjectURL\n    // eslint-disable-next-line @typescript-eslint/await-thenable\n    script.src = await url;\n    insertNode(script, doc);\n    win.URL.revokeObjectURL(url);\n}\nexport function injectScript(s, doc) {\n    if (isFirefox(doc)) {\n        injectScriptletFirefox(s, doc);\n    }\n    else {\n        injectScriptlet(s, doc);\n    }\n}\n//# sourceMappingURL=index.js.map","/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n// TODO - move to @cliqz/adblocker-content\nimport { querySelectorAll } from '@cliqz/adblocker-extended-selectors';\nimport { DOMMonitor, injectScript, } from '@cliqz/adblocker-content';\nlet ACTIVE = true;\nlet DOM_MONITOR = null;\nlet UPDATE_EXTENDED_TIMEOUT = null;\nconst PENDING = new Set();\nconst EXTENDED = [];\nconst HIDDEN = new Map();\nfunction unload() {\n    if (DOM_MONITOR !== null) {\n        DOM_MONITOR.stop();\n        DOM_MONITOR = null;\n    }\n}\n/**\n * Because all the filters and matching logic lives in the background of the\n * extension, the content script needs a way to request relevant cosmetic\n * filters for each frame. This channel of communication can be handled in\n * several ways (`connect`, `sendMessage`). Here we will make use of\n * `sendMessage` for one-off communications.\n *\n * `getCosmeticsFiltersWithSendMessage` wraps the logic of communicating with\n * the background and will be used to request cosmetics filters for the current\n * frame.\n *\n * The background should listen to these messages and answer back with lists of\n * filters to be injected in the page.\n */\nfunction getCosmeticsFiltersWithSendMessage(arg) {\n    return new Promise((resolve) => {\n        chrome.runtime.sendMessage({\n            action: 'getCosmeticsFilters',\n            ...arg,\n        }, (response) => {\n            if (response !== undefined) {\n                resolve(response);\n            }\n        });\n    });\n}\nfunction cachedQuerySelector(root, selector, cache) {\n    var _a;\n    // First check if we have a result in cache for this node and selector\n    const cachedElements = (_a = cache.get(root)) === null || _a === void 0 ? void 0 : _a.get(selector);\n    if (cachedElements !== undefined) {\n        return cachedElements;\n    }\n    const selected = new Set(querySelectorAll(root, selector.ast));\n    // Cache result for next time!\n    if (selector.attribute !== undefined) {\n        let cachedSelectors = cache.get(root);\n        if (cachedSelectors === undefined) {\n            cachedSelectors = new Map();\n            cache.set(root, cachedSelectors);\n        }\n        let cachedSelected = cachedSelectors.get(selector);\n        if (cachedSelected === undefined) {\n            cachedSelected = new Set();\n            cachedSelectors.set(selector, cachedSelected);\n        }\n        for (const element of selected) {\n            cachedSelected.add(element);\n        }\n    }\n    return selected;\n}\nfunction updateExtended() {\n    if (PENDING.size === 0 || EXTENDED.length === 0) {\n        return;\n    }\n    const cache = new Map();\n    const elementsToHide = new Map();\n    // Since we are processing elements in a delayed fashion, it is possible\n    // that some short-lived DOM nodes are already detached. Here we simply\n    // ignore them.\n    const roots = [...PENDING].filter((e) => e.isConnected === true);\n    PENDING.clear();\n    for (const root of roots) {\n        for (const selector of EXTENDED) {\n            for (const element of cachedQuerySelector(root, selector, cache)) {\n                if (selector.remove === true) {\n                    element.textContent = '';\n                    element.remove();\n                }\n                else if (selector.attribute !== undefined && HIDDEN.has(element) === false) {\n                    elementsToHide.set(element, { selector, root });\n                }\n            }\n        }\n    }\n    // Hide new nodes if any\n    for (const [element, { selector, root }] of elementsToHide.entries()) {\n        if (selector.attribute !== undefined) {\n            element.setAttribute(selector.attribute, '');\n            HIDDEN.set(element, { selector, root });\n        }\n    }\n    // Check if some elements should be un-hidden.\n    for (const [element, { selector, root }] of [...HIDDEN.entries()]) {\n        if (selector.attribute !== undefined) {\n            if (root.isConnected === false ||\n                element.isConnected === false ||\n                cachedQuerySelector(root, selector, cache).has(element) === false) {\n                HIDDEN.delete(element);\n                element.removeAttribute(selector.attribute);\n            }\n        }\n    }\n}\n/**\n * Queue `elements` to be processed asynchronously in a batch way (for\n * efficiency). This is important to not do more work than necessary, for\n * example if the same set of nodes is updated multiple times in a raw on\n * user-interaction (e.g. a dropdown); this allows to only check these nodes\n * once, and to not block the UI.\n */\nfunction delayedUpdateExtended(elements) {\n    // If we do not have any extended filters applied to this frame, then we do\n    // not need to do anything. We just ignore.\n    if (EXTENDED.length === 0) {\n        return;\n    }\n    // If root DOM element is already part of PENDING, no need to queue other elements.\n    if (PENDING.has(window.document.documentElement)) {\n        return;\n    }\n    // Queue up new elements into the global PENDING set, which will be processed\n    // in a batch maner from a setTimeout.\n    for (const element of elements) {\n        // If we get the DOM root then we can clear everything else from the queue\n        // since we will be looking at all nodes anyway.\n        if (element === window.document.documentElement) {\n            PENDING.clear();\n            PENDING.add(element);\n            break;\n        }\n        PENDING.add(element);\n    }\n    // Check if we need to trigger a setTimeout to process pending elements.\n    if (UPDATE_EXTENDED_TIMEOUT === null) {\n        UPDATE_EXTENDED_TIMEOUT = setTimeout(() => {\n            UPDATE_EXTENDED_TIMEOUT = null;\n            updateExtended();\n        }, 1000);\n    }\n}\nfunction handleResponseFromBackground(window, { active, scripts, extended }) {\n    if (active === false) {\n        ACTIVE = false;\n        unload();\n        return;\n    }\n    else {\n        ACTIVE = true;\n    }\n    // Inject scripts\n    if (scripts) {\n        for (const script of scripts) {\n            try {\n                injectScript(script, window.document);\n            }\n            catch (e) {\n                // continue regardless of error\n            }\n        }\n    }\n    // Extended CSS\n    if (extended && extended.length > 0) {\n        EXTENDED.push(...extended);\n        delayedUpdateExtended([window.document.documentElement]);\n    }\n}\n/**\n * Takes care of injecting cosmetic filters in a given window. Responsabilities:\n * - Inject scripts.\n * - Block scripts.\n *\n * NOTE: Custom stylesheets are now injected from background.\n *\n * All this happens by communicating with the background through the\n * `backgroundAction` function (to trigger request the sending of new rules\n * based on a domain or node selectors) and the `handleResponseFromBackground`\n * callback to apply new rules.\n */\nexport function injectCosmetics(window, enableMutationObserver = true, getCosmeticsFilters = getCosmeticsFiltersWithSendMessage) {\n    // Invoked as soon as content-script is injected to ask for background to\n    // inject cosmetics and scripts as soon as possible. Some extra elements\n    // might be inserted later whenever we know more about the content of the\n    // page.\n    getCosmeticsFilters({ lifecycle: 'start', ids: [], classes: [], hrefs: [] }).then((response) => handleResponseFromBackground(window, response));\n    // On DOMContentLoaded, start monitoring the DOM. This means that we will\n    // first check which ids and classes exist in the DOM as a one-off operation;\n    // this will allow the injection of selectors which have a chance to match.\n    // We also register a MutationObserver which will monitor the addition of new\n    // classes and ids, and might trigger extra filters on a per-need basis.\n    window.addEventListener('DOMContentLoaded', () => {\n        DOM_MONITOR = new DOMMonitor((update) => {\n            if (update.type === 'elements') {\n                if (update.elements.length !== 0) {\n                    delayedUpdateExtended(update.elements);\n                }\n            }\n            else {\n                getCosmeticsFilters({ ...update, lifecycle: 'dom-update' }).then((response) => handleResponseFromBackground(window, response));\n            }\n        });\n        DOM_MONITOR.queryAll(window);\n        // Start observing mutations to detect new ids and classes which would\n        // need to be hidden.\n        if (ACTIVE && enableMutationObserver) {\n            DOM_MONITOR.start(window);\n        }\n    }, { once: true, passive: true });\n    window.addEventListener('pagehide', unload, { once: true, passive: true });\n}\n//# sourceMappingURL=index.js.map",null],"names":[],"mappings":"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"}