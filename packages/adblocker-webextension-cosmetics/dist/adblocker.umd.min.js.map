{"version":3,"file":"adblocker.umd.min.js","sources":["esm/index.js"],"sourcesContent":["/*!\n * Copyright (c) 2017-present Ghostery GmbH. All rights reserved.\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n// TODO - move to @cliqz/adblocker-content\nimport { querySelectorAll } from '@cliqz/adblocker-extended-selectors';\nimport { DOMMonitor, injectScript, } from '@cliqz/adblocker-content';\nlet ACTIVE = true;\nlet DOM_MONITOR = null;\nlet UPDATE_EXTENDED_TIMEOUT = null;\nconst PENDING = new Set();\nconst EXTENDED = [];\nconst HIDDEN = new Map();\nfunction unload() {\n    if (DOM_MONITOR !== null) {\n        DOM_MONITOR.stop();\n        DOM_MONITOR = null;\n    }\n}\n/**\n * Because all the filters and matching logic lives in the background of the\n * extension, the content script needs a way to request relevant cosmetic\n * filters for each frame. This channel of communication can be handled in\n * several ways (`connect`, `sendMessage`). Here we will make use of\n * `sendMessage` for one-off communications.\n *\n * `getCosmeticsFiltersWithSendMessage` wraps the logic of communicating with\n * the background and will be used to request cosmetics filters for the current\n * frame.\n *\n * The background should listen to these messages and answer back with lists of\n * filters to be injected in the page.\n */\nfunction getCosmeticsFiltersWithSendMessage(arg) {\n    return new Promise((resolve) => {\n        chrome.runtime.sendMessage({\n            action: 'getCosmeticsFilters',\n            ...arg,\n        }, (response) => {\n            if (response !== undefined) {\n                resolve(response);\n            }\n        });\n    });\n}\nfunction cachedQuerySelector(root, selector, cache) {\n    var _a;\n    // First check if we have a result in cache for this node and selector\n    const cachedElements = (_a = cache.get(root)) === null || _a === void 0 ? void 0 : _a.get(selector);\n    if (cachedElements !== undefined) {\n        return cachedElements;\n    }\n    const selected = new Set(querySelectorAll(root, selector.ast));\n    // Cache result for next time!\n    if (selector.attribute !== undefined) {\n        let cachedSelectors = cache.get(root);\n        if (cachedSelectors === undefined) {\n            cachedSelectors = new Map();\n            cache.set(root, cachedSelectors);\n        }\n        let cachedSelected = cachedSelectors.get(selector);\n        if (cachedSelected === undefined) {\n            cachedSelected = new Set();\n            cachedSelectors.set(selector, cachedSelected);\n        }\n        for (const element of selected) {\n            cachedSelected.add(element);\n        }\n    }\n    return selected;\n}\nfunction updateExtended() {\n    if (PENDING.size === 0 || EXTENDED.length === 0) {\n        return;\n    }\n    const cache = new Map();\n    const elementsToHide = new Map();\n    // Since we are processing elements in a delayed fashion, it is possible\n    // that some short-lived DOM nodes are already detached. Here we simply\n    // ignore them.\n    const roots = [...PENDING].filter((e) => e.isConnected === true);\n    PENDING.clear();\n    for (const root of roots) {\n        for (const selector of EXTENDED) {\n            for (const element of cachedQuerySelector(root, selector, cache)) {\n                if (selector.remove === true) {\n                    element.textContent = '';\n                    element.remove();\n                }\n                else if (selector.attribute !== undefined && HIDDEN.has(element) === false) {\n                    elementsToHide.set(element, { selector, root });\n                }\n            }\n        }\n    }\n    // Hide new nodes if any\n    for (const [element, { selector, root }] of elementsToHide.entries()) {\n        if (selector.attribute !== undefined) {\n            element.setAttribute(selector.attribute, '');\n            HIDDEN.set(element, { selector, root });\n        }\n    }\n    // Check if some elements should be un-hidden.\n    for (const [element, { selector, root }] of [...HIDDEN.entries()]) {\n        if (selector.attribute !== undefined) {\n            if (root.isConnected === false ||\n                element.isConnected === false ||\n                cachedQuerySelector(root, selector, cache).has(element) === false) {\n                HIDDEN.delete(element);\n                element.removeAttribute(selector.attribute);\n            }\n        }\n    }\n}\n/**\n * Queue `elements` to be processed asynchronously in a batch way (for\n * efficiency). This is important to not do more work than necessary, for\n * example if the same set of nodes is updated multiple times in a raw on\n * user-interaction (e.g. a dropdown); this allows to only check these nodes\n * once, and to not block the UI.\n */\nfunction delayedUpdateExtended(elements) {\n    // If we do not have any extended filters applied to this frame, then we do\n    // not need to do anything. We just ignore.\n    if (EXTENDED.length === 0) {\n        return;\n    }\n    // If root DOM element is already part of PENDING, no need to queue other elements.\n    if (PENDING.has(window.document.documentElement)) {\n        return;\n    }\n    // Queue up new elements into the global PENDING set, which will be processed\n    // in a batch maner from a setTimeout.\n    for (const element of elements) {\n        // If we get the DOM root then we can clear everything else from the queue\n        // since we will be looking at all nodes anyway.\n        if (element === window.document.documentElement) {\n            PENDING.clear();\n            PENDING.add(element);\n            break;\n        }\n        PENDING.add(element);\n    }\n    // Check if we need to trigger a setTimeout to process pending elements.\n    if (UPDATE_EXTENDED_TIMEOUT === null) {\n        UPDATE_EXTENDED_TIMEOUT = setTimeout(() => {\n            UPDATE_EXTENDED_TIMEOUT = null;\n            updateExtended();\n        }, 1000);\n    }\n}\nfunction handleResponseFromBackground(window, { active, scripts, extended }) {\n    if (active === false) {\n        ACTIVE = false;\n        unload();\n        return;\n    }\n    else {\n        ACTIVE = true;\n    }\n    // Inject scripts\n    if (scripts) {\n        for (const script of scripts) {\n            try {\n                injectScript(script, window.document);\n            }\n            catch (e) {\n                // continue regardless of error\n            }\n        }\n    }\n    // Extended CSS\n    if (extended && extended.length > 0) {\n        EXTENDED.push(...extended);\n        delayedUpdateExtended([window.document.documentElement]);\n    }\n}\n/**\n * Takes care of injecting cosmetic filters in a given window. Responsabilities:\n * - Inject scripts.\n * - Block scripts.\n *\n * NOTE: Custom stylesheets are now injected from background.\n *\n * All this happens by communicating with the background through the\n * `backgroundAction` function (to trigger request the sending of new rules\n * based on a domain or node selectors) and the `handleResponseFromBackground`\n * callback to apply new rules.\n */\nexport function injectCosmetics(window, enableMutationObserver = true, getCosmeticsFilters = getCosmeticsFiltersWithSendMessage) {\n    // Invoked as soon as content-script is injected to ask for background to\n    // inject cosmetics and scripts as soon as possible. Some extra elements\n    // might be inserted later whenever we know more about the content of the\n    // page.\n    getCosmeticsFilters({ lifecycle: 'start', ids: [], classes: [], hrefs: [] }).then((response) => handleResponseFromBackground(window, response));\n    // On DOMContentLoaded, start monitoring the DOM. This means that we will\n    // first check which ids and classes exist in the DOM as a one-off operation;\n    // this will allow the injection of selectors which have a chance to match.\n    // We also register a MutationObserver which will monitor the addition of new\n    // classes and ids, and might trigger extra filters on a per-need basis.\n    window.addEventListener('DOMContentLoaded', () => {\n        DOM_MONITOR = new DOMMonitor((update) => {\n            if (update.type === 'elements') {\n                if (update.elements.length !== 0) {\n                    delayedUpdateExtended(update.elements);\n                }\n            }\n            else {\n                getCosmeticsFilters({ ...update, lifecycle: 'dom-update' }).then((response) => handleResponseFromBackground(window, response));\n            }\n        });\n        DOM_MONITOR.queryAll(window);\n        // Start observing mutations to detect new ids and classes which would\n        // need to be hidden.\n        if (ACTIVE && enableMutationObserver) {\n            DOM_MONITOR.start(window);\n        }\n    }, { once: true, passive: true });\n    window.addEventListener('pagehide', unload, { once: true, passive: true });\n}\n//# sourceMappingURL=index.js.map"],"names":["ACTIVE","DOM_MONITOR","UPDATE_EXTENDED_TIMEOUT","PENDING","Set","EXTENDED","HIDDEN","Map","unload","stop","getCosmeticsFiltersWithSendMessage","arg","Promise","resolve","chrome","runtime","sendMessage","action","response","undefined","cachedQuerySelector","root","selector","cache","_a","cachedElements","get","selected","querySelectorAll","ast","attribute","cachedSelectors","set","cachedSelected","element","add","delayedUpdateExtended","elements","length","has","window","document","documentElement","clear","setTimeout","size","elementsToHide","roots","filter","e","isConnected","remove","textContent","entries","setAttribute","delete","removeAttribute","updateExtended","handleResponseFromBackground","active","scripts","extended","script","injectScript","push","enableMutationObserver","getCosmeticsFilters","lifecycle","ids","classes","hrefs","then","addEventListener","DOMMonitor","update","type","queryAll","start","once","passive"],"mappings":"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"}